---
title: Análisis exploratorio de un conjunto de datos de indicadores urbanos
author:
  - name: Rebeca Company
    affil: 1,2,\dagger
  - name: Alejandro Dionis
    affil: 1,3,\dagger
  - name: Gabriel Ivars
    affil: 1,4,\dagger
  - name: Julio Garcia
    affil: 1,5,\dagger
affiliation:
  - num: 1
    address: |
      Universitat de València -
      ETSE-UV, Avinguda de l'Universitat, 46100 Burjassot, Valencia
  - num: 2
    address: |
      Máster Universitario en Ciencia de Datos
    email: recombar@alumni.uv.es
  - num: 3
    address: |
      Máster Universitario en Ciencia de Datos
    email: adioros@alumni.uv.es
  - num: 4
    address: |
      Máster Universitario en Ciencia de Datos
    email: gaia2@alumni.uv.es
  - num: 5
    address: |
      Máster Universitario en Ciencia de Datos
    email: jugarbus@alumni.uv.es    
# author citation list in chicago format
authorcitation: |
  Company, R.; Dionis, A.; Ivars, G.; Garcia, J.
# firstnote to eighthnote
firstnote: |
  Todos los autores contribuyeron de manera equitativa a este trabajo.
correspondence: |
  etse@uv.es; Tel.: +34-963-54-3211.
  
# document options
journal: Universitat de València
type: article
status: submit
# front matter
simplesummary: |
  El presente artículo es un proyecto de la Asignatura Análisis Exploratorio de Datos, en el que se realiza un análisis exploratorio del conjunto de datos de Indicadores Urbanos, publicado por el Instituto Nacional de Estadística.
abstract: |
  REDACTAR MÁS TARDE
# back matter
keywords: |
  Indicadores Urbanos; Tasa ; Población; REVISAR MAS TARDE
authorcontributions: |
    Todos los autores contribuyeron de manera equitativa a este trabajo.
funding: |
  This research received no external funding.
dataavailability: |
  Los conjuntos de datos analizados en el presente artículo están disponibles en la sección "Indicadores Urbanos. Últimos datos." del repositorio público de conjuntos de datos abiertos del Instituto Nacional de Estadística INEbase
  \url{https://www.ine.es/dyngs/INEbase/listaoperaciones.htm}.
conflictsofinterest: |
  Los autores declaran no tener ningún conflicto de interés
abbreviations:
  - short: MDPI
    long: Multidisciplinary Digital Publishing Institute
  - short: INE
    long: Instituto Nacional de Estadística
  - short: RMT
    long: REVISAR MAS TARDE
bibliography: mybibfile.bib
appendix: appendix.tex
# To use endnotes, change endnotes: true , then use \endnote{This 28 is an endnote.}.
endnotes: false
output: 
  rticles::mdpi_article:
    extra_dependencies: longtable
always_allow_html: true
---


```{r setup, include=FALSE, fig.align='left'}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, out.width = '70%')
```



# Introducción

Hablar de los 3 datasets y de donde se han obtenido. BLABLABLA



# Objetivos



# Análisis exploratorio de los datos



## Importación de los datos

```{r, include=FALSE}
rm(list = ls())
pacman::p_load(readr, tidyverse, ggplot2, dplyr, plotly, lubridate, visdat, knitr) # verifica si los paquetes están instalados y, si no lo están, los instala y luego los carga
```


```{r, include=FALSE}
getOption("encoding")
guess_encoding("./data/demograficos.csv")
guess_encoding("./data/economicos.csv")
guess_encoding("./data/sociales.csv")
#El encoding es de UTF-8 en los 3 ficheros de datos
```


```{r, include=FALSE}
dem <- read_delim("./data/demograficos.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE, show_col_types = FALSE)

eco <- read_delim("./data/economicos.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE, show_col_types = FALSE)

soc <- read_delim("./data/sociales.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE, show_col_types = FALSE)
```




```{r, include=FALSE}
#La variable Total del dataset social es de tipo character cuando debería ser numérica.
soc <- soc %>%
  mutate(Total = str_replace_all(Total, "\\.", "")) %>%  # Eliminar separadores de miles
  mutate(Total = str_replace_all(Total, ",", ".")) %>%   # Cambiar comas por puntos
  mutate(Total = as.numeric(Total))                      # Transformar a tipo numérico
```


```{r, include=FALSE}
#Al modificar el tipo de la variable Total se aprecia un aumento del número de valores faltantes. Exploremos los posibles motivos. 

df_ori <- read_delim("./data/sociales.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE)

na_diff <- which(!is.na(df_ori$Total) & is.na(soc$Total))
diff_observations <- df_ori[na_diff, , drop = FALSE]
diff_observations

# Hay 1461 observaciones en el dataframe social con un valor de ".." en la variable Total
```



```{r, include=FALSE}
# Transformar variable Periodo a tipo fecha y extraer solo el año

dem_2 <- dem %>%
  mutate(Periodo = ymd(paste0(Periodo, "-01-01")))

eco_2 <- eco %>%
  mutate(Periodo = ymd(paste0(Periodo, "-01-01")))

soc_2 <- soc %>%
  mutate(Periodo = ymd(paste0(Periodo, "-01-01")))
```



```{r, include=FALSE}
# Los datos faltantes en la variable Municipios son los valores asociados a Total Nacional. Por lo que se va a eliminar la columna Total Nacional y se van a rellenar los NA con el Valor "Total Nacional".
# También se modifica la variable sexo para que sea de tipo factor.

DEM<- dem_2 %>% replace_na(list(Municipios = "Total Nacional")) %>% select(-"Total Nacional") %>%  mutate(
                    Sexo = as.factor(Sexo))
ECO<- eco_2 %>% replace_na(list(Municipios = "Total Nacional")) %>% select(-"Total Nacional") %>%  mutate(
                    Sexo = as.factor(Sexo))
SOC<- soc_2 %>% replace_na(list(Municipios = "Total Nacional")) %>% select(-"Total Nacional") %>%  mutate(
                    Sexo = as.factor(Sexo))
```




```{r, include=FALSE}
# Se concatenan los 3 datasets ya que tienen formato tidy y no hay coincidencias en la variable 'Indicadores', que es común a todos los dataframes.
full_df <- bind_rows(DEM, ECO, SOC)
```




```{r, include=FALSE}
# Datos Totales Nacionales (Sexo=Total)
total_df <- full_df %>% filter(Municipios=='Total Nacional') %>% filter(Sexo=='Total') %>% select(-Sexo)

# Datos Totales Nacionales por sexo
total_bysex_df <- full_df %>% filter(Municipios=='Total Nacional') %>% filter(Sexo!='Total')


# Datos por municipios (Sexo=Total)
mun_df <- full_df %>% filter(Municipios!='Total Nacional') %>% filter(Sexo=='Total') %>% select(-Sexo) 

# Datos por municipios y sexo
mun_bysex_df <- full_df %>% filter(Municipios!='Total Nacional') %>% filter(Sexo!='Total')


# Datos sin sexo solamente

total_df_nosex <- full_df %>% filter(Sexo=='Total') %>% select(-Sexo) 

```




Antes de importar, primero se verificó que la codificación de los tres datasets fuera la misma, confirmando que todos estaban en formato UTF-8. Una vez comprobado, a la hora de importar los datasets, fue necesario establecer el delimitador de campos con el punto y coma (;) y adaptar el formato original al de R, ya que en los datasets el decimal_mark es la coma (,) y el grouping_mark es el punto (.). Las variables a estudiar, las cuales son coincidentes en los tres datasets, son:


- *Total Nacional* : Variable redundante con un único valor "Total Nacional", que toma verdadero valor cuando el atributo *Municipios* es vacío. 

- *Municipios* : Municipio del que se han obtenido los datos.

- *Indicadores* : Tipo de estadístico demográfico, económico o social que se está calculando en cada observación (se comentarán mas a fondo después del análisis de datos faltantes).

- *Sexo* : Sexo del cual se está obteniendo el indicador estadístico (hombre o mujer).

- *Periodo* : Año al que hace referencia el indicador estadístico.

- *Total* : Valor numérico asociado al indicador estadístico, que puede ser un valor absoluto, una tasa o un porcentaje, dependiendo del tipo de estadístico.



Otras consideraciones que se tuvieron en cuenta fué que la variable *Total* del dataset social era de tipo character y se transformó a tipo numeric para poder realizar operaciones. Esto se debe a que esta columna contenía valores "..", que serán considerados como faltantes en nuestro análisis. Al importar estos valores, R determinó que la clase de esta variable era de tipo character.

Además, se transformó la variable *Periodo* a tipo Date y la variable *Sexo* a tipo factor.


Posteriormente se concatenaron los tres datasets ya que tienen formato tidy y no hay niveles coincidentes (todos son únicos) en la columna *Indicadores*, que es común a todos los dataframes.



Finalmente, el dataset se separó en varias partes:

- Datos totales nacionales con *Sexo* = "Total".

- Datos totales nacionales por sexo.

- Datos por municipios con *Sexo* = "Total".

- Datos por municipios y sexo.



Esto se hizo porque no tenía sentido estudiar los datos de forma conjunta, ya que muchos de los indicadores tienen distintas escalas. No obstante, también se ha guardado el dataset completo ya que es necesario para el estudio de los datos faltantes.




## Análisis de datos faltantes


```{r, include=FALSE}
# Comprobar filas duplicadas
duplicated_rows <- full_df %>%
  filter(duplicated(full_df))

# Ver las filas duplicadas
print(duplicated_rows)

#No hay duplicados
```



En esta sección previa al análisis univariante y bivariante se va a realizar un análisis de la estructura de los faltantes y del dataset en general. Para asegurar que nuestro conjunto de datos sea coherente, evaluaremos el porcentaje de valores faltantes (NA) presentes en cada variable:




```{r}
colSums(is.na(full_df)) / dim(full_df)[1] *100
```


Únicamente se observan valores faltantes en la variable *Total*, y este valor es muy elevado. 

Es importante señalar que durante la importación de los datasets, se eliminaron los datos faltantes en la variable Municipios que correspondían a los valores asociados a "Total Nacional". Por esta razón, se eliminó la columna Total Nacional y se rellenaron los valores NA de *Municipios* con el valor "Total Nacional".

También se observó que al modificar el tipo de la variable *Total* se apreció un aumento del número de valores faltantes.  Esto se debió a que había 1461 observaciones en el dataframe social con un valor de ".." en la variable *Total* que al transformarlos a numéricos, R los asoció a valores NA.

Además, no se encontraron observaciones duplicadas a lo largo del dataset completo.

A continuación se van a estudiar estos NAs en función del resto variables no numéricas.


#### Por sexo


```{r}
full_df %>% 
  filter(is.na(Total)) %>%
  count(Sexo, sort = TRUE) %>%
  ggplot(aes(x = reorder(Sexo, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "Conteo de Sexo con Valores NA en Total",
      x = "Sexo",
      y = "Cantidad de NA"
    ) +
    theme_minimal()
```

```{r}
n_na_sex <- full_df %>% 
  filter(is.na(Total)) %>%
  count(Sexo, sort = TRUE)

total_sex <- full_df %>% 
  count(Sexo, sort = TRUE)

n_na_sex$perc <- n_na_sex$n / total_sex$n * 100
n_na_sex$perc_total <- n_na_sex$n / dim(full_df)[1] * 100



n_na_sex

```




Tanto para Hombres como para Mujeres, aproximadamente el 85.91% de sus observaciones tienen valores faltantes en la columna Total, lo que representa el 28.64% del total de observaciones en el dataframe. Para la categoría Total, el 41.97% de sus observaciones tienen valores faltantes, representando el 13.99% del total de observaciones en el dataframe. Por tanto, debido al elevado porcentaje de valores faltantes en las observaciones desglosadas por sexo, decidimos no incluir en el análisis observaciones de hombres y mujeres por separado y optamos por trabajar únicamente con el total combinado de ambos sexos.


```{r}
# (total_df_nosex) Ahora solo se va a usar el dataset Sexo=Total 
```


#### Por indicadores

```{r}
total_df_nosex %>% 
  filter(is.na(Total)) %>%
  count(Indicadores, sort = TRUE) %>%
  ggplot(aes(x = reorder(Indicadores, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "Conteo NAs",
      x = "Indicadores",
      y = "Cantidad de NAs"
    ) +
    theme_minimal()
```


Como se observa en la gráfica superior, la distribución de los NAs por cada indicador no es uniforme. Por tanto, como criterio, se van a prescindir de los que superen el 75% de valores faltantes relativo al total de observaciones para cada indicador. Con este criterio se descartarían los 13 indicadores con mas NAs que se pueden visualizar en la gráfica superior. Estos indicadores corresponden la mayoría al dataset económico.


```{r, include=FALSE}
# Obtenemos los porcenntajes de valores faltantes
na_ind_count <- total_df_nosex %>% 
  filter(is.na(Total)) %>%
  count(Indicadores, sort = TRUE)

total_ind <- total_df_nosex %>% 
  count(Indicadores, sort = TRUE)

na_ind_count$perc <- na_ind_count$n / total_ind$n * 100

na_ind_list <- na_ind_count[na_ind_count$perc < 75,]
na_ind_list


# Eliminamos los indicadores que tengan más de 75% de valores faltantes
clean_total_df_nosex <- total_df_nosex %>% 
  filter(Indicadores %in% na_ind_list$Indicadores)
```





#### Por periodo





```{r}
clean_total_df_nosex %>% 
  filter(is.na(Total)) %>%
  count(Periodo, sort = TRUE) %>%
  ggplot(aes(x = Periodo, y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los años estén en el eje y
    labs(
      title = "Conteo de Periodo con Valores NAs en Total",
      x = "Periodo",
      y = "Cantidad de NAs"
    ) +
  scale_x_continuous(breaks =  unique(clean_total_df_nosex$Periodo)) +
  theme_minimal()
```


```{r}
n_na_period <- clean_total_df_nosex %>% 
  filter(is.na(Total)) %>%
  count(Periodo, sort = TRUE)

total_period <- clean_total_df_nosex %>% 
  count(Periodo, sort = TRUE)

n_na_period$perc <- n_na_period$n / total_period$n * 100
n_na_period$perc_total <- n_na_period$n / dim(clean_total_df_nosex)[1] * 100



n_na_period

```




El periodo del año 2010 hasta el año 2014 y los año 2022 y 2023 son los años con mayor número de valores faltantes. No obstante, como representan menos de un 2% de faltantes del total de observaciones, estos valores van a ser imputados, ya que también, su porcentaje relativo tampoco es muy elevado.


Se observa una mejora de valores faltantes (11.34%) al prescindir de la variable Sexo y de los indicadores con mayor proporción de NAs:

```{r}
colSums(is.na(clean_total_df_nosex)) / dim(clean_total_df_nosex)[1] *100
```

Aun así, estos valores van a ser imputados mediante una medida de tendencia central, dependiendo del indicador al que esté asociada cada observación.


#### Imputación



```{r}
clean_total_df <- clean_total_df_nosex %>% filter(Municipios=='Total Nacional')
clean_mun_df <- clean_total_df_nosex %>% filter(Municipios!='Total Nacional')
```






```{r}
# Imputacion por municipios

# Ajustar las opciones para mostrar números en notación decimal
options(scipen = 999)


medianas <- clean_mun_df %>%
  group_by(Indicadores) %>%
  summarise(mediana_total = median(Total, na.rm = TRUE))

medias <- clean_mun_df %>%
  group_by(Indicadores) %>%
  summarise(media_total = mean(Total, na.rm = TRUE))

diff <- abs(medianas[,2] - medias[,2])

# Como en ciertos indicadores difiere mucho la mediana de la media se imputa con la mediana

```




```{r}
mun_data <- clean_mun_df %>%
  left_join(medianas, by = "Indicadores") %>%
  mutate(Total = ifelse(is.na(Total), mediana_total, Total)) %>%
  select(-mediana_total)  # Eliminar la columna de medianas después de la imputación

```



```{r}
# Imputacion del Total Nacional

# Ajustar las opciones para mostrar números en notación decimal
options(scipen = 999)


medianas_total <- clean_total_df %>%
  group_by(Indicadores) %>%
  summarise(mediana_total = median(Total, na.rm = TRUE))

medias_total <- clean_total_df %>%
  group_by(Indicadores) %>%
  summarise(media_total = mean(Total, na.rm = TRUE))

diff_total <- abs(medianas_total[,2] - medias_total[,2])

# Como en ciertos indicadores difiere mucho la mediana de la media se imputa con la mediana

```

```{r}
total_data <- clean_total_df %>%
  left_join(medianas_total, by = "Indicadores") %>%
  mutate(Total = ifelse(is.na(Total), mediana_total, Total)) %>%
  select(-mediana_total)  # Eliminar la columna de medianas después de la imputación

```



Para asegurar la consistencia de los datos, se realizó una imputación de los valores faltantes en la columna *Total.* Para llevar a cabo la imputación, se realizó por separado en dos datasets: uno para los valores separados por municipios, y otro para el total nacional. Después, para cada dataset se calcularon tanto la media como la mediana de *Total* para cada grupo de Indicadores. Luego, se compararon estas dos medidas y se observó que, en ciertos indicadores, la diferencia entre la media y la mediana era significativa. Debido a estas discrepancias, se decidió utilizar la mediana para la imputación, ya que es menos sensible a los valores atípicos. Finalmente, se imputaron los valores faltantes en la columna *Total* con la mediana correspondiente a cada grupo de Indicadores, asegurando así una representación más robusta y precisa de los datos.







## Análisis univariante 

```{r}
# mun_data  DATAFRAME POR MUNICIPIOS LIMPIO
# total_data DATAFRAME TOTAL NACIONAL LIMPIO

```

### Características generales

En esta sección se lleva a cabo un análisis preeliminar de los dos datasets que van a ser estudiados, prestando especial atención a las posibles anomalías, como datos inconsistentes u outliers.

Se estudian paralelamente los dos dataframes: uno de ellos contiene los valores de los indicadores para cada municipio (`r nrow(mun_data)` observaciones), y el otro  los valores del total nacional (`r nrow(total_data)` observaciones). Ambos sets de datos contienen las siguientes variables:

```{r}
codebook <- data.frame(
  Variable = colnames(mun_data),
  Tipo = c("Texto","Texto","Fecha","Numérica"),
  Niveles = c(
    length(unique(c(total_data$Municipios, mun_data$Municipios))),
    length(unique(c(total_data$Indicadores, mun_data$Indicadores))),
    length(unique(c(total_data$Periodo, mun_data$Periodo))),
    "N/A"),
  Valores = c(
    paste(c(head(unique(c(as.character(total_data$Municipios), as.character(mun_data$Municipios))), 2),
          "...",
          tail(unique(c(as.character(total_data$Municipios), as.character(mun_data$Municipios))), 1)), 
          collapse = ", "),
    paste(c(head(unique(c(as.character(total_data$Indicadores), as.character(mun_data$Indicadores))), 1),
          "...",
          tail(unique(c(as.character(total_data$Indicadores), as.character(mun_data$Indicadores))), 1)), 
          collapse = ", "),
    paste(range(c(mun_data$Periodo, total_data$Periodo)), collapse = " - "),
    paste(range(c(mun_data$Total, total_data$Total)), collapse = " - ")),
  Descripción = c(
    "Municipio del que se han obtenido los datos.", 
    "Estadístico demográfico, económico o social que se está calculando.",
    "Año al que hace referencia el indicador estadístico.",
    "Valor numérico asociado al indicador estadístico, que puede ser un valor absoluto, una tasa o un porcentaje.")
  )


    
kable(codebook)
     
```

Sin embargo, para nuestro análisis es relevante considerar cada indicador como una variable individual, en lugar de mantenerlos agrupados en la columna *Indicadores*. 
Para facilitar la posterior manipulación de los datos, optamos por transformar los datasets a formato wide, de manera que quede cada indicador como una variable nueva. Además, se abrevian los nombres de los indicadores. 

```{r}

mun_wide <- pivot_wider(mun_data, names_from="Indicadores", values_from="Total")
total_wide <- pivot_wider(total_data, names_from="Indicadores", values_from="Total")

abrev <- c("Municipios", "Periodo", "Pob_Residente", 
               "Prop_0_14", "Prop_15_64", "Prop_65", "Edad_Mediana",
               "Prop_Nacionales", "Prop_Nativos", "Prop_Nacidos_Extranjero",
               "Prop_Extranjeros", "Tasa_Natalidad", "Tasa_Mortalidad", 
               "Esperanza_Vida", "Num_Hijos_Mujer", "Tasa_Desempleo",
               "Prop_Ocupados_20_64", "Tasa_Actividad", "Prop_Empleo_Servicios",
               "Prop_Empleo_Industria", "Num_Hogares", "Tam_Hogares",
               "Prop_Hogares_1Persona", "Num_Viviendas_Catastro")

summary_indicadores <- data.frame(
  Indicador = colnames(mun_wide)[-c(1,2)],
  Abreviatura = abrev[-c(1,2)]
)

names(mun_wide) <- abrev
names(total_wide) <- abrev

```

En el caso de las variables *Municipio* y *Periodo*, son consideradas como variables no númericas y se han revisado sus valores únicos y sus frecuencias absolutas y relativas, para asegurar que no hay ninguna anomalía.

```{r, include = FALSE}
# Obtenemos las frecuencias aboslutas de la variable Municipios
sort(table(mun_wide$Municipios))

# Obtenemos las frecuencias aboslutas de la variable Municipios, en ambos dfs
sort(table(mun_wide$Periodo))
sort(table(mun_wide$Periodo))

# Al realizar este analisis después de la limpieza inicial de los datos y su imputación, vemos que todos los municipios y los periodos estan igualmente representados
```


Respecto a las variables numéricas, se revisan sus principales estadísticos descriptivos, para detectar posibles: valores negativos, tasas o proporciones mayores que 100, etc... De nuevo no se detectan inconsistencias.

```{r include=FALSE}
# En el caso del dataset por municipios:
summary(mun_wide[-c(1,2)])

# En el caso del dataset de Total Nacional:
summary(mun_wide[-c(1,2)])

```

### Exploración visual

Para buscar valores anómalos se decide graficar los indicadores en boxplots. 

```{r}
# Escalar las variables numéricas restando la media y dividiendo entre la desviación estandar para poder comparar todos los indicadores en un solo grafico
# Convertir a formato largo para poder obtener el gráfico con ggplot2
mun_data_transformed <- mun_wide %>%
  mutate(across(where(is.numeric), scale)) %>%
  pivot_longer(cols = where(is.numeric), 
               names_to = "Indicadores", 
               values_to = "Total")

ggplot(mun_data_transformed, aes(x = Indicadores, y = Total)) +
  geom_boxplot(fill = "darkturquoise", color = "black") + 
  theme_minimal() +
  labs(
    title = "Boxplot de los Indicadores por municipios",
    x = "Indicador",
    y = "Total"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotar las etiquetas del eje x
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  )
```
```{r}
# Convertir a formato largo para poder obtener el gráfico con ggplot2
total_data_transformed <- total_wide %>%
  mutate(across(where(is.numeric), scale)) %>%
  pivot_longer(cols = where(is.numeric), 
               names_to = "Indicadores", 
               values_to = "Total")

ggplot(total_data_transformed, aes(x = Indicadores, y = Total)) +
  geom_boxplot(fill = "darkturquoise", color = "black") + 
  theme_minimal() +
  labs(
    title = "Boxplot de los Indicadores de Total Nacional",
    x = "Indicador",
    y = "Total"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotar las etiquetas del eje x
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  )
```

Se considera relevante estudiar individualmente aquellos indicadores que parecen susceptibles de presentar datos anómalos:

* De los datos por municipios, los indicadores: *Número de hogares*, *Número de Viviendas según Catastro* y *Población residente*, ya que parecen presentar una subpoblación con valores muy elevados.

* De los datos del Total Nacional: *Esperanza de Vida*, *Número de Hogares*, *Número de Viviendas según Catastro*, *Proporción de Población entre 0 y 14 años*, *Proporción de Empleos en Industria*, *Proporción de Empleo en Servicios y Tasa de Mortalidad*.

```{r}
# Seleccionamos los indicadores que tenemos que revisar
revisar_mun <- abrev <- c("Pob_Residente",  "Num_Hogares", "Num_Viviendas_Catastro")

graficos1 = list()
# Realizamos boxplots interactivos con puntos (jitter)
for (r in revisar_mun){
 
   # Grafico con ggplot
  ggplot_box <- 
    ggplot(mun_wide, aes(x = "1", y = mun_wide[[r]])) +
    geom_boxplot( fill = "darkturquoise", alpha = 0.5) +
    geom_jitter( aes( text = paste( "Municipio:", Municipios, "<br>Periodo:", Periodo,"<br>Total", mun_wide[[r]] )), width = 0.2, height = 0, shape = 21, color = "black", fill = "darkturquoise", alpha = 0.7) +
    theme_minimal() +
    labs( y = " ", x = r ) +
    theme( axis.title.x = element_text(face = "bold"), axis.text.x = element_blank(), axis.ticks.x = element_blank() )
  
  # Convertir el gráfico a interactivo
  interactive_plot <- ggplotly(ggplot_box, tooltip = "text")
  
  # Guardar el gráfico en una lista
  graficos1 <- append(graficos1, list(interactive_plot))
}


revisar_total <- abrev <- c("Prop_0_14", 
               "Esperanza_Vida", "Tasa_Mortalidad", "Prop_Empleo_Servicios",
               "Prop_Empleo_Industria", "Num_Hogares", "Num_Viviendas_Catastro")

graficos2 = list()
# Realizamos boxplots interactivos con puntos (jitter)
for (r in revisar_total[6:7]){
  # Grafico con ggplot
  ggplot_box <- 
    ggplot(total_wide, aes(x = "1", y = total_wide[[r]])) +
    geom_boxplot( fill = "darkturquoise", alpha = 0.5) +
    geom_jitter( aes( text = paste("Periodo:", Periodo,"<br>Total", total_wide[[r]]  )), width = 0.2, height = 0, shape = 21, color = "black", fill = "darkturquoise", alpha = 0.7) +
    theme_minimal() +
    labs( y = " ", x = r ) +
    theme( axis.title.x = element_text(face = "bold"), axis.text.x = element_blank(), axis.ticks.x = element_blank() )
  
  # Convertir el gráfico a interactivo
  interactive_plot <- ggplotly(ggplot_box, tooltip = "text")
  
  # Guardar el gráfico en una lista
  graficos2 <- append(graficos2, list(interactive_plot))
}

graficos3 = list()
# Realizamos boxplots interactivos con puntos (jitter)
for (r in revisar_total[c(2,4)]){
  # Grafico con ggplot
  ggplot_box <- 
    ggplot(total_wide, aes(x = "1", y = total_wide[[r]])) +
    geom_boxplot( fill = "darkturquoise", alpha = 0.5) +
    geom_jitter( aes( text = paste( "Periodo:", Periodo,"<br>Total", total_wide[[r]] )), width = 0.2, height = 0, shape = 21, color = "black", fill = "darkturquoise", alpha = 0.7) +
    theme_minimal() +
    labs( y = " ", x = r ) +
    theme( axis.title.x = element_text(face = "bold"), axis.text.x = element_blank(), axis.ticks.x = element_blank() )
  
  # Convertir el gráfico a interactivo
  interactive_plot <- ggplotly(ggplot_box, tooltip = "text")
  
  # Guardar los gráficos en una lista
  graficos3 <- append(graficos3, list(interactive_plot))
}

graficos4 = list()
# Realizamos boxplots interactivos con puntos (jitter)
for (r in revisar_total[c(1,3,5)]){
  # Grafico con ggplot
  ggplot_box <- 
    ggplot(total_wide, aes(x = "1", y = total_wide[[r]])) +
    geom_boxplot( fill = "darkturquoise", alpha = 0.5) +
    geom_jitter( aes( text = paste( "Periodo:", Periodo,"<br>Total", total_wide[[r]] )), width = 0.2, height = 0, shape = 21, color = "black", fill = "darkturquoise", alpha = 0.7) +
    theme_minimal() +
    labs( y = " ", x = r ) +
    theme( axis.title.x = element_text(face = "bold"), axis.text.x = element_blank(), axis.ticks.x = element_blank() )
  
  # Convertir el gráfico a interactivo
  interactive_plot <- ggplotly(ggplot_box, tooltip = "text")
  
  # Guardar los gráficos en una lista
  graficos4 <- append(graficos4, list(interactive_plot))
}

# Juntamos los gráficos
y_min <- 0
y_max <- max(mun_wide[, revisar_mun]) + 160000
ticks <- seq(y_min, y_max, by = 500000)
subplot(graficos1, nrows = 1, shareX = TRUE, shareY = TRUE) %>% layout(yaxis = list(range = c(y_min, y_max), tickvals = ticks))

y_min <- min(total_wide[, revisar_total[6:7]], na.rm = TRUE) - 1000000
y_max <- max(total_wide[, revisar_total[6:7]]) + 1200000
ticks <- seq(y_min, y_max, by = 1000000)
subplot(graficos2, nrows = 1, shareX = TRUE, shareY = TRUE) %>% layout(yaxis = list(range = c(y_min, y_max), tickvals = ticks))

y_min <- min(total_wide[, revisar_total[c(2,4)]]) - 1
y_max <- max(total_wide[, revisar_total[c(2,4)]]) + 1
ticks <- seq(y_min, y_max, by = 10)
subplot(graficos3, nrows = 1, shareX = TRUE, shareY = TRUE) %>% layout(yaxis = list(range = c(y_min, y_max), tickvals = ticks))

y_min <- min(total_wide[, revisar_total[c(1,3,5)]]) - 1
y_max <- max(total_wide[, revisar_total[c(1,3,5)]]) + 1
ticks <- seq(y_min, y_max, by = 10)
subplot(graficos4, nrows = 1, shareX = TRUE, shareY = TRUE) %>% layout(yaxis = list(range = c(y_min, y_max), tickvals = ticks))

```

* En el caso del dataset por municipios:

  + Para las variables *Población Residente*, *Número de Hogares* y *Número de Viviendas según Catastro*, los valores más altos son los correspondientes a los municipios Madrid y Barcelona, lo que tiene sentido al ser los municipios más poblados, y por lo tanto estos datos no son considerados anómalos.
  
En el caso del dataset del Total Nacional:

  + La variable *Número de Hogares* presenta un valor bastante bajo pero el año 2010, sin embargo, vemos que es un valor que se ajusta a la tendencia creciente del número de hogares a lo largo de los años, por lo tanto no se trata de un dato anómalo.
  
```{r}
ggplot(data = total_wide, aes(y = Num_Hogares, x = Periodo)) +
  geom_line(color = "darkturquoise", size = 1) +
  theme_minimal()
```

  +  La variable de *Número de Viviendas según Catastro* no aparecía en el boxplot múltiple. Esto se debe a que en el dataset original, solo se ha registrado el Total Nacional de esta variable en el año 2023, y al imputar el resto de valores con la mediana, todos los años terminan teniendo el mismo valor total. Posteriormente, al restar la media durante el proceso de estandarización, todos los valores de esta variable se convierten en 0, lo que impide que aparezca en el gráfico.
  
```{r}
# Obtenemos los porcentajes de valores faltantes
na_ind_count <- clean_total_df %>% 
  filter(is.na(Total)) %>%
  count(Indicadores, name = "missing", sort = TRUE)

total_ind <- clean_total_df %>% 
  count(Indicadores, name = "n", sort = TRUE)

na_ind_count <- na_ind_count %>%
  left_join(total_ind, by = "Indicadores") %>%
  mutate(perc = (missing / n) * 100)

kable(na_ind_count)

```

  +  En el caso de la variable *Esperanza de Vida* vemos que hay valores que superan los "límites" superior e inferior, pero siguen siendo muy similares al resto, ya que la desviación típica de esta variable es muy pequeña, `r sd(total_wide$Esperanza_Vida)`. Por lo tanto tampoco se consideran valores anómalos. 
  
  +  En las variables *Proporción de Empleo en Servicios* y *Proporción de Empleo en Industria*, observamos una situación similar a la anterior (variables con desviación típica pequeña y rango reducido). Además, los valores más "extremos" corresponden a los mismos años, pero se comportan de manera inversa entre sí. De nuevo, estos valores no se consideran anómalos.
  
```{r}
prop_empleos <- data.frame(
  Variable = c("Prop_Empleo_Industria", "Prop_Empleo_Servicios"),
  SD = c(sd(total_wide$Prop_Empleo_Industria), sd(total_wide$Prop_Empleo_Servicios)),
  Mínimo = c(min(total_wide$Prop_Empleo_Industria), min(total_wide$Prop_Empleo_Servicios)),
  Máximo = c(max(total_wide$Prop_Empleo_Industria), max(total_wide$Prop_Empleo_Servicios))
)
kable(prop_empleos)

# df_prop_empleos <- total_wide[c("Periodo", "Prop_Empleo_Industria", "Prop_Empleo_Servicios")]
# 
# ggplot(df_prop_empleos)+
#   geom_line(aes(x = Periodo, y = Prop_Empleo_Industria, color = "darkturquoise"))+
#   geom_line(aes(x = Periodo, y = Prop_Empleo_Servicios, color = "darkred"))+
#   scale_y_continuous(limits = c(0, 100))
```

  
  +  En el caso de la variable *Proporción de población de  0-14 años*, el dato `r max(total_wide$Prop_0_14)` sí se considera un dato anómalo, ya que es un valor muy alto en comparación al resto (el resto de valores de la variable oscilan entre `r range(total_wide$Prop_0_14[-which.max(total_wide$Prop_0_14)])`%). Además, para cada observación, la suma de las variables *Prop_0_14*, *Prop_15_64* y *Prop_65* da un resultado muy cercano al 100%, pero para en el caso del dato anómalo la suma resulta en `r sum(total_wide[which.max(total_wide$Prop_0_14),4:6])`.
Se decide corregir este valor para que la suma de las tres proporciones sea 100.

```{r}
# Reemplazamos en el formato wide
i <- which.max(total_wide$Prop_0_14)
nuevo_valor <- 100 - total_wide$Prop_15_64[i] - total_wide$Prop_65[i]
total_wide$Prop_0_14[i] <- nuevo_valor 


# Reemplazamos en el formato long
i <- total_data %>%
  filter(Indicadores == "Proporción de población de  0-14 años (Porcentaje)") %>%
  pull(Total) %>% which.max()

total_data[i, "Total"] <- nuevo_valor


```

  + Finalmente revisamos el valor máximo de la variable *Tasa de Mortalidad*. Aunque es superior a los demás, la diferencia no es excesiva. Este valor corresponde al año 2020, por lo que el aumento en la tasa de mortalidad podría estar relacionado con la pandemia de COVID-19. A pesar de que este dato podría tener un impacto significativo, no se considera un valor anómalo.

### Estadísticos descriptivos

Una vez eliminado e imputado el dato anómalo encontrado, se vuelven a calcular los estadisticos descriptivos de las variables numéricas, es decir, de todos los indicadores de ambos datasets.

```{r}
# En el caso del dataset por municipios:

numericas <- mun_wide %>% select(where(is.numeric))

estadisticos <- data.frame(
  Abreviatura = character(),
  Min = numeric(),
  Q1 = numeric(),
  Media = numeric(),
  Mediana = numeric(),
  Q3 = numeric(),
  Max = numeric(),
  Rango = numeric(),
  SD = numeric()
)

for (i in 1:ncol(numericas)) {
  
  indicador <- colnames(numericas)[i]
  estadisticos[i, "Abreviatura"] <- indicador
  estadisticos[i, "Min"] <- min(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Q1"] <- quantile(numericas[[indicador]], 0.25, na.rm = TRUE)
  estadisticos[i, "Media"] <- mean(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Mediana"] <- median(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Q3"] <- quantile(numericas[[indicador]], 0.75, na.rm = TRUE)
  estadisticos[i, "Max"] <- max(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Rango"] <- max(numericas[[indicador]], na.rm = TRUE) - min(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "SD"] <- sd(numericas[[indicador]], na.rm = TRUE)
}

summary_indicadores_mun <- inner_join(summary_indicadores, estadisticos)

kable(summary_indicadores_mun)


# En el caso del dataset de Total Nacional:

numericas <- total_wide %>% select(where(is.numeric))

estadisticos <- data.frame(
  Abreviatura = character(),
  Min = numeric(),
  Q1 = numeric(),
  Media = numeric(),
  Mediana = numeric(),
  Q3 = numeric(),
  Max = numeric(),
  Rango = numeric(),
  SD = numeric()
)

for (i in 1:ncol(numericas)) {
  
  indicador <- colnames(numericas)[i]
  estadisticos[i, "Abreviatura"] <- indicador
  estadisticos[i, "Min"] <- min(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Q1"] <- quantile(numericas[[indicador]], 0.25, na.rm = TRUE)
  estadisticos[i, "Media"] <- mean(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Mediana"] <- median(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Q3"] <- quantile(numericas[[indicador]], 0.75, na.rm = TRUE)
  estadisticos[i, "Max"] <- max(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "Rango"] <- max(numericas[[indicador]], na.rm = TRUE) - min(numericas[[indicador]], na.rm = TRUE)
  estadisticos[i, "SD"] <- sd(numericas[[indicador]], na.rm = TRUE)
}

summary_indicadores_total <- inner_join(summary_indicadores, estadisticos)

kable(summary_indicadores_total)

```

## Análisis bivariante

```{r}
# mun_data  DATAFRAME POR MUNICIPIOS LIMPIO
# total_data DATAFRAME TOTAL NACIONAL LIMPIO
```
