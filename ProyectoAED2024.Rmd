---
title: Análisis exploratorio de un conjunto de datos de indicadores urbanos
author:
  - name: Rebeca Company
    affil: 1,2,\dagger
  - name: Alejandro Dionis
    affil: 1,3,\dagger
  - name: Gabriel Ivars
    affil: 1,4,\dagger
  - name: Julio Garcia
    affil: 1,5,\dagger
affiliation:
  - num: 1
    address: |
      Universitat de València -
      ETSE-UV, Avinguda de l'Universitat, 46100 Burjassot, Valencia
  - num: 2
    address: |
      Máster Universitario en Ciencia de Datos
    email: recombar@alumni.uv.es
  - num: 3
    address: |
      Máster Universitario en Ciencia de Datos
    email: adioros@alumni.uv.es
  - num: 4
    address: |
      Máster Universitario en Ciencia de Datos
    email: gaia2@alumni.uv.es
  - num: 5
    address: |
      Máster Universitario en Ciencia de Datos
    email: jugarbus@alumni.uv.es    
# author citation list in chicago format
authorcitation: |
  Company, R.; Dionis, A.; Ivars, G.; Garcia, J.
# firstnote to eighthnote
firstnote: |
  Todos los autores contribuyeron de manera equitativa a este trabajo.
correspondence: |
  etse@uv.es; Tel.: +34-963-54-3211.
  
# document options
journal: Universitat de València
type: article
status: submit
# front matter
simplesummary: |
  El presente artículo es un proyecto de la Asignatura Análisis Exploratorio de Datos, en el que se realiza un análisis exploratorio del conjunto de datos de Indicadores Urbanos, publicado por el Instituto Nacional de Estadística.
abstract: |
  REDACTAR MÁS TARDE
# back matter
keywords: |
  Indicadores Urbanos; Tasa ; Población; REVISAR MAS TARDE
authorcontributions: |
    Todos los autores contribuyeron de manera equitativa a este trabajo.
funding: |
  This research received no external funding.
dataavailability: |
  Los conjuntos de datos analizados en el presente artículo están disponibles en la sección "Indicadores Urbanos. Últimos datos." del repositorio público de conjuntos de datos abiertos del Instituto Nacional de Estadística INEbase
  \url{https://www.ine.es/dyngs/INEbase/listaoperaciones.htm}.
conflictsofinterest: |
  Los autores declaran no tener ningún conflicto de interés
abbreviations:
  - short: MDPI
    long: Multidisciplinary Digital Publishing Institute
  - short: INE
    long: Instituto Nacional de Estadística
  - short: RMT
    long: REVISAR MAS TARDE
bibliography: mybibfile.bib
appendix: appendix.tex
# To use endnotes, change endnotes: true , then use \endnote{This 28 is an endnote.}.
endnotes: false
output: 
  rticles::mdpi_article:
    extra_dependencies: longtable
---


```{r setup, include=FALSE, fig.align='left'}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, out.width = '70%')
```



# Introducción

Hablar de los 3 datasets y de donde se han obtenido. BLABLABLA



# Objetivos



# Análisis exploratorio de los datos



## Importación de los datos

```{r, include=FALSE}
rm(list = ls())
pacman::p_load(readr, tidyverse, ggplot2, dplyr, plotly, lubridate, visdat, ggpubr, mapSpain) # verifica si los paquetes están instalados y, si no lo están, los instala y luego los carga
```


```{r, include=FALSE}
getOption("encoding")
guess_encoding("./data/demograficos.csv")
guess_encoding("./data/economicos.csv")
guess_encoding("./data/sociales.csv")
#El encoding es de UTF-8 en los 3 ficheros de datos
```


```{r, include=FALSE}
dem <- read_delim("./data/demograficos.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE, show_col_types = FALSE)

eco <- read_delim("./data/economicos.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE, show_col_types = FALSE)

soc <- read_delim("./data/sociales.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE, show_col_types = FALSE)
```




```{r, include=FALSE}
#La variable Total del dataset social es de tipo character cuando debería ser numérica.
soc <- soc %>%
  mutate(Total = str_replace_all(Total, "\\.", "")) %>%  # Eliminar separadores de miles
  mutate(Total = str_replace_all(Total, ",", ".")) %>%   # Cambiar comas por puntos
  mutate(Total = as.numeric(Total))                      # Transformar a tipo numérico
```


```{r, include=FALSE}
#Al modificar el tipo de la variable Total se aprecia un aumento del número de valores faltantes. Exploremos los posibles motivos. 

df_ori <- read_delim("./data/sociales.csv", delim = ";", escape_double = FALSE, locale = locale(decimal_mark = ",", grouping_mark = "."), trim_ws = TRUE)

na_diff <- which(!is.na(df_ori$Total) & is.na(soc$Total))
diff_observations <- df_ori[na_diff, , drop = FALSE]
diff_observations

# Hay 1461 observaciones en el dataframe social con un valor de ".." en la variable Total
```



```{r, include=FALSE}
# Transformar variable Periodo a tipo fecha

dem_2 <- dem %>%
  mutate(Periodo = ymd(paste0(Periodo, "-01-01")))

eco_2 <- eco %>%
  mutate(Periodo = ymd(paste0(Periodo, "-01-01")))

soc_2 <- soc %>%
  mutate(Periodo = ymd(paste0(Periodo, "-01-01")))
```



```{r, include=FALSE}
# Los datos faltantes en la variable Municipios son los valores asociados a Total Nacional. Por lo que se va a eliminar la columna Total Nacional y se van a rellenar los NA con el Valor "Total Nacional".
# También se modifica la variable sexo para que sea de tipo factor.

DEM<- dem_2 %>% replace_na(list(Municipios = "Total Nacional")) %>% select(-"Total Nacional") %>%  mutate(
                    Sexo = as.factor(Sexo))
ECO<- eco_2 %>% replace_na(list(Municipios = "Total Nacional")) %>% select(-"Total Nacional") %>%  mutate(
                    Sexo = as.factor(Sexo))
SOC<- soc_2 %>% replace_na(list(Municipios = "Total Nacional")) %>% select(-"Total Nacional") %>%  mutate(
                    Sexo = as.factor(Sexo))
```




```{r, include=FALSE}
# Se concatenan los 3 datasets ya que tienen formato tidy y no hay coincidencias en la variable 'Indicadores', que es común a todos los dataframes.
full_df <- bind_rows(DEM, ECO, SOC)
```




```{r, include=FALSE}
# Datos juntos sin sexo solamente

total_df_nosex <- full_df %>% filter(Sexo=='Total') %>% select(-Sexo) 
```




Antes de importar, primero se verificó que la codificación de los tres datasets fuera la misma, confirmando que todos estaban en formato UTF-8. Una vez comprobado, a la hora de importar los datasets, fue necesario establecer el delimitador de campos con el punto y coma (;) y adaptar el formato original al de R, ya que en los datasets el decimal_mark es la coma (,) y el grouping_mark es el punto (.). Las variables a estudiar, las cuales son coincidentes en los tres datasets, son:


- *Total Nacional* : Variable redundante con un único valor "Total Nacional", que toma verdadero valor cuando el atributo *Municipios* es vacío. 

- *Municipios* : Municipio del que se han obtenido los datos.

- *Indicadores* : Tipo de estadístico demográfico, económico o social que se está calculando en cada observación. Se comentarán mas a fondo en los hallazgos obtenidos, ya que se trata de un elevado número de indicadores.

- *Sexo* : Sexo del cual se está obteniendo el indicador estadístico (hombre o mujer).

- *Periodo* : Año al que hace referencia el indicador estadístico.

- *Total* : Valor numérico asociado al indicador estadístico, que puede ser un valor absoluto, una tasa o un porcentaje, dependiendo del tipo de estadístico.



Otras consideraciones que se tuvieron en cuenta fué que la variable *Total* del dataset social era de tipo character y se transformó a tipo numeric para poder realizar operaciones. Esto se debe a que esta columna contenía valores "..", que serán considerados como faltantes en nuestro análisis. Al importar estos valores, R determinó que la clase de esta variable era de tipo character.

Además, se transformó la variable *Periodo* a tipo Date y la variable *Sexo* a tipo factor.


Posteriormente se concatenaron los tres datasets ya que tienen formato tidy.



Finalmente, el dataset se separó en varias partes:

- Datos totales nacionales con *Sexo* = "Total".

- Datos totales nacionales por sexo.

- Datos por municipios con *Sexo* = "Total".

- Datos por municipios y sexo.



Esto se hizo porque no tenía sentido estudiar los datos de forma conjunta, ya que muchos de los indicadores tienen distintas escalas. No obstante, también se ha guardado el dataset completo ya que es necesario para el estudio de los datos faltantes.




## Análisis de datos faltantes


```{r, include=FALSE}
# Comprobar filas duplicadas
duplicated_rows <- full_df %>%
  filter(duplicated(full_df))

# Ver las filas duplicadas
print(duplicated_rows)

#No hay duplicados
```



En esta sección previa al análisis univariante y bivariante se va a realizar un análisis de la estructura de los faltantes y del dataset en general. Para asegurar que nuestro conjunto de datos sea coherente, evaluaremos el porcentaje de valores faltantes (NA) presentes en cada variable:




```{r}
colSums(is.na(full_df)) / dim(full_df)[1] *100
```


Del dataset completo, es decir, sin discriminar por total nacional ni sexo, únicamente se observan valores faltantes en la variable *Total*, siendo este un valor muy elevado. 

Es importante señalar que durante la importación de los datasets, se eliminaron los datos faltantes en la variable Municipios que correspondían a los valores asociados a "Total Nacional". Por esta razón, se eliminó la columna Total Nacional y se rellenaron los valores NA de *Municipios* con el valor "Total Nacional".

También se observó que al modificar el tipo de la variable *Total* se apreció un incremento del número de valores faltantes.  Esto se debió a las 1461 observaciones del dataframe social con un valor de ".." que al transformarlos a numéricos, R los asoció a valores NA.

Además, no se encontraron observaciones duplicadas a lo largo del dataset completo.

A continuación se van a estudiar estos valores faltantes en función del resto variables no numéricas.


#### Por sexo


```{r}
g1 <- full_df %>% filter(Municipios=='Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Sexo, sort = TRUE) %>%
  ggplot(aes(x = reorder(Sexo, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "Conteo NAs por Sexo del dataset total nacional",
      x = "Sexo",
      y = "Cantidad de NA"
    ) +
    theme_minimal()

g2 <- full_df %>% filter(Municipios!='Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Sexo, sort = TRUE) %>%
  ggplot(aes(x = reorder(Sexo, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "Conteo NAs de por Sexo del dataset por municipios",
      x = "Sexo",
      y = "Cantidad de NA"
    ) +
    theme_minimal()



ggarrange(g1, g2, nrow = 2)

```

```{r}
#Porcentajes NAs de Sexo dataset Total Nacional
n_na_sex <- full_df %>% filter(Municipios=='Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Sexo, sort = TRUE)

total_sex <- full_df %>% filter(Municipios=='Total Nacional') %>% 
  count(Sexo, sort = TRUE)

n_na_sex$perc <- n_na_sex$n / total_sex$n * 100
n_na_sex$perc_total <- n_na_sex$n / dim(full_df %>% filter(Municipios=='Total Nacional'))[1] * 100



n_na_sex

```


```{r}
#Porcentaje NAs de Sexo dataset por municipios
n_na_sex_2 <- full_df %>% filter(Municipios!='Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Sexo, sort = TRUE)

total_sex_2 <- full_df %>% filter(Municipios!='Total Nacional') %>% 
  count(Sexo, sort = TRUE)

n_na_sex_2$perc <- n_na_sex_2$n / total_sex_2$n * 100
n_na_sex_2$perc_total <- n_na_sex_2$n / dim(full_df %>% filter(Municipios!='Total Nacional'))[1] * 100



n_na_sex_2

```




Tanto para hombres como para mujeres, aproximadamente el 85% de sus observaciones tienen valores faltantes en la columna *Total*, lo que representa mas o menos el 28% del total de observaciones en ambos conjuntos de datos. Para el nivel Total (variable *Sexo*), en torno al 40% de sus observaciones tienen valores faltantes, representando el 14% aproximandamente del total de observaciones en ambos dataframes. Por tanto, debido al elevado porcentaje de valores faltantes en las observaciones desglosadas por sexo, decidimos no incluir en el análisis observaciones de hombres y mujeres por separado y optamos por trabajar únicamente con el total combinado de ambos sexos. Por tanto, a partir de ahora se va a realizar el análisis sobre estos dos datasets:

- Datos totales nacionales con *Sexo* = "Total".


- Datos por municipios con *Sexo* = "Total".




```{r}
# (total_df_nosex) Ahora solo se va a usar el dataset Sexo=Total 
```


#### Por indicadores

```{r}
nombres_originales <- unique(total_df_nosex$Indicadores)

nombres_abreviados <- c("Pob_Res", "Pob_0_14", "Pob_15_64", "Pob_65más", "Edad_Med", 
                       "Nac_Total", "Nat_Nac_Total", "Nac_Ext_Total", "Ext_Total", 
                       "Tasa_Natalidad", "Tasa_Mortalidad", "Esp_Vida", "Hijos_Mujer", 
                       "Tasa_Desempleo", "Ocup_20_64", "Tasa_Actividad", "Emp_Servicios", 
                       "Emp_Industria", "Renta_Hogar", "Renta_Hab", "Renta_UC", "Num_Hogares", 
                       "Tam_Hogar", "Hog_1P", "Viv_Catastro", "Viv_Censo", "Viv_Vacías", 
                       "Alq_m2_Anual", "Alq_Mensual", "Med_Alq_m2_Anual", "Med_Alq_Mensual", 
                       "Q1_Alq_m2_Anual", "Q1_Alq_Mensual", "Q3_Alq_m2_Anual", "Q3_Alq_Mensual")

# Abraviar los nombres de la variable Indicadores almacenandolos en la variable Ind
total_df_nosex <- total_df_nosex %>%
  mutate(Ind = recode(Indicadores, 
                     !!!setNames(nombres_abreviados, nombres_originales)))
```


```{r}
 g3 <- total_df_nosex %>% filter(Municipios=='Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Ind, sort = TRUE) %>%
  ggplot(aes(x = reorder(Ind, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "NAs por Indicadores del dataset total nacional",
      x = "Indicadores",
      y = "Cantidad de NA"
    ) +
    theme_minimal()

g4 <-  total_df_nosex %>% filter(Municipios!='Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Ind, sort = TRUE) %>%
  ggplot(aes(x = reorder(Ind, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "NAs por Indicadores del dataset total nacional",
      x = "Indicadores",
      y = "Cantidad de NA"
    ) +
    theme_minimal()

ggarrange(g3, g4, nrow = 2, heights = c(1, 1))


```



Como se observa en la gráfica superior, la distribución de los NAs por cada indicador no es uniforme en los dos datasets. Por tanto, como criterio, se van a prescindir de los que superen el 50% de valores faltantes relativo al total de observaciones para cada indicador.



```{r}
# Obtenemos los porcentajes de valores faltantes dataset Total Nacional
na_ind_count <- total_df_nosex %>% 
  filter(Municipios == 'Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Indicadores, sort = TRUE)

# Obtenemos el total de indicadores
total_ind <- total_df_nosex %>% 
  filter(Municipios == 'Total Nacional') %>% 
  count(Indicadores, sort = TRUE)

# Unimos ambos dataframes para que tengan el mismo número de filas
result <- total_ind %>%
  left_join(na_ind_count, by = "Indicadores", suffix = c("_total", "_na"))

# Reemplazamos los NA en la columna de conteo de valores faltantes por 0
result <- result %>%
  mutate(n_na = ifelse(is.na(n_na), 0, n_na))

# Calculamos el porcentaje de valores faltantes
result <- result %>%
  mutate(perc = (n_na / n_total) * 100) %>%
  arrange(desc(perc))

na_ind_list <- result[result$perc < 50,]


# Eliminamos los indicadores que tengan más de 50% de valores faltantes
clean_total_df <- total_df_nosex %>% filter(Municipios=='Total Nacional') %>% 
  filter(Indicadores %in% na_ind_list$Indicadores)
```



```{r}
# Obtenemos los porcentajes de valores faltantes dataset por municipios
na_ind_count_2 <- total_df_nosex %>% filter(Municipios!='Total Nacional') %>% 
  filter(is.na(Total)) %>%
  count(Indicadores, sort = TRUE)

total_ind_2 <- total_df_nosex %>% filter(Municipios!='Total Nacional') %>% 
  count(Indicadores, sort = TRUE) 

na_ind_count_2$perc <- na_ind_count_2$n / total_ind_2$n * 100

na_ind_list_2 <- na_ind_count_2[na_ind_count_2$perc < 50,]



# Eliminamos los indicadores que tengan más de 50% de valores faltantes
clean_mun_df <- total_df_nosex %>% filter(Municipios!='Total Nacional') %>% 
  filter(Indicadores %in% na_ind_list_2$Indicadores)
```



#### Por periodo





```{r}
 g5 <- clean_total_df %>%
  filter(is.na(Total)) %>%
  count(Periodo, sort = TRUE) %>%
  ggplot(aes(x = reorder(Periodo, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "NAs por año del dataset total nacional",
      x = "Periodo",
      y = "Cantidad de NA"
    ) +
    theme_minimal()

g6 <- clean_mun_df %>%
  filter(is.na(Total)) %>%
  count(Periodo, sort = TRUE) %>%
  ggplot(aes(x = reorder(Periodo, n), y = n)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Voltea el gráfico para que los indicadores estén en el eje y
    labs(
      title = "NAs por año del dataset por municipios",
      x = "Periodo",
      y = "Cantidad de NA"
    ) +
    theme_minimal()

ggarrange(g5, g6, nrow = 2, heights = c(1, 1.5))
```


```{r}
# Obtenemos los porcentajes de valores faltantes dataset Total Nacional
na_period_count <- clean_total_df %>%
  filter(is.na(Total)) %>%
  count(Periodo, sort = TRUE)

# Obtenemos el total de Periodos
total_period <- clean_total_df %>%
  count(Periodo, sort = TRUE)

# Unimos ambos dataframes para que tengan el mismo número de filas
result_period <- total_period %>%
  left_join(na_period_count, by = "Periodo", suffix = c("_total", "_na"))

# Reemplazamos los NA en la columna de conteo de valores faltantes por 0
result_period <- result_period %>%
  mutate(n_na = ifelse(is.na(n_na), 0, n_na))

# Calculamos el porcentaje de valores faltantes
result_period <- result_period %>%
  mutate(perc = (n_na / n_total) * 100) %>% 
  mutate(perc_total = (n_na / dim(clean_total_df)[1]) * 100) %>%
  arrange(desc(perc))

print(head(result_period, 5))
```


```{r}
n_na_period_2 <- clean_mun_df %>% 
  filter(is.na(Total)) %>%
  count(Periodo, sort = TRUE, name = "n_na")

total_period_2 <- clean_mun_df %>% 
  count(Periodo, sort = TRUE)


n_na_period_2$n_total <- total_period_2$n

n_na_period_2$perc <- n_na_period_2$n_na / total_period_2$n * 100
n_na_period_2$perc_total <- n_na_period_2$n_na / dim(clean_mun_df)[1] * 100



print(head(n_na_period_2, 8))

```


El análisis de los datos faltantes revela patrones interesantes. En ambos conjuntos de datos, el año 2023 presenta la mayor proporción de valores faltantes. Sin embargo, en el dataset municipal, se observa un período de estabilidad con un bajo porcentaje de datos faltantes entre 2010 y 2013. A pesar de estas variaciones, el porcentaje total de datos faltantes es relativamente bajo, inferior al 2%. Por lo tanto, se procederá a imputar estos valores para completar el conjunto de datos.


Finalmente se observa una mejora de valores faltantes al prescindir de la variable Sexo y de los indicadores con mayor proporción de NAs:

```{r}
colSums(is.na(clean_mun_df)) / dim(clean_mun_df)[1] *100
```
```{r}
colSums(is.na(clean_total_df)) / dim(clean_total_df)[1] *100
```


Estos valores van a ser imputados mediante una medida de tendencia central, dependiendo del indicador al que esté asociada cada observación.


#### Imputación




```{r}
# Imputacion del dataset Total Nacional

# Ajustar las opciones para mostrar números en notación decimal
options(scipen = 999)


medianas_total <- clean_total_df %>%
  group_by(Indicadores) %>%
  summarise(mediana_total = median(Total, na.rm = TRUE))

medias_total <- clean_total_df %>%
  group_by(Indicadores) %>%
  summarise(media_total = mean(Total, na.rm = TRUE))

diff_total <- abs(medianas_total[,2] - medias_total[,2])

# Como en ciertos indicadores difiere mucho la mediana de la media se imputa con la mediana

```

```{r}
total_data <- clean_total_df %>%
  left_join(medianas_total, by = "Indicadores") %>%
  mutate(Total = ifelse(is.na(Total), mediana_total, Total)) %>%
  select(-mediana_total)  # Eliminar la columna de medianas después de la imputación

```







```{r}
# Imputacion del dataset por municipios

# Ajustar las opciones para mostrar números en notación decimal
options(scipen = 999)


medianas_mun <- clean_mun_df %>%
  group_by(Indicadores) %>%
  summarise(mediana_mun = median(Total, na.rm = TRUE))

medias_mun <- clean_mun_df %>%
  group_by(Indicadores) %>%
  summarise(media_mun = mean(Total, na.rm = TRUE))

diff_mun <- abs(medianas_mun[,2] - medias_mun[,2])

# Como en ciertos indicadores difiere mucho la mediana de la media se imputa con la mediana

```




```{r}
mun_data <- clean_mun_df %>%
  left_join(medianas_mun, by = "Indicadores") %>%
  mutate(Total = ifelse(is.na(Total), mediana_mun, Total)) %>%
  select(-mediana_mun)  # Eliminar la columna de medianas después de la imputación

```



Para asegurar la consistencia de los datos, se realizó una imputación de los valores faltantes en la columna *Total.* Para llevar a cabo la imputación, se realizó por separado en dos datasets: uno para los valores separados por municipios, y otro para el total nacional. Después, para cada dataset se calcularon tanto la media como la mediana de *Total* para cada grupo de Indicadores. Luego, se compararon estas dos medidas y se observó que, en ciertos indicadores, la diferencia entre la media y la mediana era significativa. Debido a estas discrepancias, se decidió utilizar la mediana para la imputación, ya que es menos sensible a los valores atípicos. Finalmente, se imputaron los valores faltantes en la columna *Total* con la mediana correspondiente a cada grupo de Indicadores.







## Análisis univariante

```{r}
# mun_data  DATAFRAME POR MUNICIPIOS LIMPIO
# total_data DATAFRAME TOTAL NACIONAL LIMPIO
```



## Análisis bivariante

```{r}
# mun_data  DATAFRAME POR MUNICIPIOS LIMPIO
# total_data DATAFRAME TOTAL NACIONAL LIMPIO
```


## Visualizacion Mapas

Para visualizar los datos de toda España, utilizaremos la librería mapSpain. Esta herramienta nos permite representar diversos indicadores sobre el mapa español y dispone de funciones para obtener los nombres de todos los municipios de España. El primer paso consistirá en comprobar que los nombres de los municipios en nuestra base de datos coinciden con los proporcionados por la librería, y resolver cualquier discrepancia que pueda existir.

```{r}
library(mapSpain)
```


```{r}
# Obtener los datos de municipios usando esp_get_munic
map_municipios <- esp_get_munic()

#print(map_municipios$name)
#print(unique(map_municipios$ine.ccaa.name))
# Extraer nombres de los municipios
map_municipios_names <- unique(map_municipios$name)
mun_data_names <- unique(mun_data$Municipios)

# Comparar nombres
matched <- mun_data_names %in% map_municipios_names
names_not_matched <- mun_data_names[!matched]

names_not_matched_corrected <- c("Alcoy / Alcoi", "Alicante / Alacant", "Castellón de la Plana / Castelló de la Plana", "Donostia / San Sebastián", "Elche / Elx", "Palma de Mallorca", "Pamplona / Iruña", "Sagunto / Sagunt", "San Vicente del Raspeig / Sant Vicent del Raspeig", "Valencia")

# Mostrar resultados
print("Municipios que coinciden:")
print(mun_data_names[matched])

print("Municipios que no coinciden:")
print(names_not_matched)
print(names_not_matched_corrected)
```

```{r}
map_municipios <- esp_get_munic()
map_municipios_names <- unique(map_municipios$name) # Nombres municipios en la libreria mapSpain

mun_data_names <- unique(mun_data$Municipios) # Nonmbres municipios en nuestro df

matched <- mun_data_names %in% map_municipios_names # Nombres que coinciden
names_not_matched <- mun_data_names[!matched] # Nombres que no coinciden

print("Municipios que no coinciden:")
print(names_not_matched)

```

Comprobamos manualmente como estan guardados los nombres que no coinciden en la librería mapSpain y lo ajustamos en nuestros datos.

```{r} 
names_not_matched_corrected <- c("Alcoy / Alcoi", "Alicante / Alacant", "Castellón de la Plana / Castelló de la Plana", "Donostia / San Sebastián", "Elche / Elx", "Palma de Mallorca", "Pamplona / Iruña", "Sagunto / Sagunt", "San Vicente del Raspeig / Sant Vicent del Raspeig", "Valencia")

names_mapping <- setNames(names_not_matched_corrected, names_not_matched)

mun_data_corrected <- mun_data %>%
  mutate(Municipios = recode(Municipios, !!!names_mapping))

```

Comprobamos que en nuestros datos ya no tenemos ningun municipio guardado como en la lista de no coincidencias y que estan los 10 municipios corregidos.

```{r}
dim(mun_data_corrected[mun_data_corrected$Municipios %in% names_not_matched,]) 
dim(mun_data_corrected[mun_data_corrected$Municipios %in% names_not_matched_corrected,]) == dim(mun_data[mun_data$Municipios %in% names_not_matched,])
```

## EJEMPLOS REPRESENTACIONES

```{r}
library(sf)
```


```{r}
mun_data_2010 <- mun_data %>%
  filter(Periodo == as.Date("2010-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")
mun_data_2013 <- mun_data %>%
  filter(Periodo == as.Date("2013-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")
mun_data_2016 <- mun_data %>%
  filter(Periodo == as.Date("2016-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")
mun_data_2019 <- mun_data %>%
  filter(Periodo == as.Date("2019-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")


map_municipios <- esp_get_munic()

# Unir los datos espaciales con los datos filtrados
map_municipios_2010 <- map_municipios %>%
  left_join(mun_data_2010, by = c("name" = "Municipios"))
map_municipios_2010 <- map_municipios_2010 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  ungroup()

map_provincias_sf <- esp_get_prov()
map_provincias_sf <- st_as_sf(map_provincias_sf)


map_provincias_sf_2010 <- st_join(map_municipios_2010,map_provincias_sf, left = T)
# Crear el mapa
g1 <- ggplot(data = map_provincias_sf_2010) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2010",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")

map_municipios_2013 <- map_municipios %>%
  left_join(mun_data_2013, by = c("name" = "Municipios"))
map_municipios_2013 <- map_municipios_2013 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  ungroup()


# Crear el mapa
g2 <- ggplot(data = map_municipios_2013) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2013",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")

map_municipios_2016 <- map_municipios %>%
  left_join(mun_data_2016, by = c("name" = "Municipios"))
map_municipios_2016 <- map_municipios_2016 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  ungroup()


# Crear el mapa
g3 <- ggplot(data = map_municipios_2016) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2016",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")

map_municipios_2019 <- map_municipios %>%
  left_join(mun_data_2019, by = c("name" = "Municipios"))
map_municipios_2019 <- map_municipios_2019 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  ungroup()


# Crear el mapa
g4 <- ggplot(data = map_municipios_2019) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2019",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")
library(gridExtra)
print(g1)

```

```{r}
grid.arrange(g1, g2, g3, g4, nrow=2, ncol=2)
```







```{r}
mun_data_2010 <- mun_data %>%
  filter(Periodo == as.Date("2010-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")
mun_data_2013 <- mun_data %>%
  filter(Periodo == as.Date("2013-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")
mun_data_2016 <- mun_data %>%
  filter(Periodo == as.Date("2016-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")
mun_data_2019 <- mun_data %>%
  filter(Periodo == as.Date("2019-01-01"),
         Indicadores == "Tasa de desempleo (Porcentaje)")


map_municipios <- esp_get_munic()

# Unir los datos espaciales con los datos filtrados
map_municipios_2010 <- map_municipios %>%
  left_join(mun_data_2010, by = c("name" = "Municipios"))
map_municipios_2010 <- map_municipios_2010 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  group_by(ine.prov.name, Total) %>%
  summarise(geometry = st_union(geometry), .groups = "drop")

g1 <- ggplot(data = map_municipios_2010) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2010",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")

map_municipios_2013 <- map_municipios %>%
  left_join(mun_data_2013, by = c("name" = "Municipios"))
map_municipios_2013 <- map_municipios_2013 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  group_by(ine.prov.name, Total) %>%
  summarise(geometry = st_union(geometry), .groups = "drop")

g2 <- ggplot(data = map_municipios_2013) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2013",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")

map_municipios_2016 <- map_municipios %>%
  left_join(mun_data_2016, by = c("name" = "Municipios"))
map_municipios_2016 <- map_municipios_2016 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  group_by(ine.prov.name, Total) %>%
  summarise(geometry = st_union(geometry), .groups = "drop")

g3 <- ggplot(data = map_municipios_2016) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2016",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")

map_municipios_2019 <- map_municipios %>%
  left_join(mun_data_2019, by = c("name" = "Municipios"))
map_municipios_2019 <- map_municipios_2019 %>%
  group_by(ine.prov.name) %>%
  mutate(Total = mean(Total, na.rm = TRUE)) %>%
  group_by(ine.prov.name, Total) %>%
  summarise(geometry = st_union(geometry), .groups = "drop")

g4 <- ggplot(data = map_municipios_2019) +
  geom_sf(aes(fill = Total), color = "white") +  # Colorear por el indicador
  scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +  # Escala de color
  theme_minimal() +
  labs(title = "Tasa de desempleo (Porcentaje)",
       subtitle = "Año 2019",
       fill = "Porcentaje",
       caption = "Fuente: Datos propios y mapSpain")


grid.arrange(g1, g2, g3, g4, nrow=2, ncol=2)

```



# TODOS LOS MAPAS
Creamos todos los mapas (todos los indicadores y años) y los guardamos en un directorio llamado "graficos_mapas".

```{r}
# Crear directorio para guardar los mapas
output_dir <- "graficos_mapas"
dir.create(output_dir, showWarnings = FALSE)

indicadores <- unique(mun_data$Indicadores)
map_municipios <- esp_get_munic()

for (indicador in indicadores) {
  mun_data_generico <- mun_data %>%
    filter(Indicadores == indicador)
  
  # Calculamos la fecha de inicio y fin del indicador
  fech_inicio <- min(mun_data_generico$Periodo)
  fech_final <- max(mun_data_generico$Periodo)
  fechas_bucle <- seq(fech_inicio, fech_final, by = "year")
  
  for (fecha in fechas_bucle) {
    fecha <- as.Date(fecha)
    mun_data_generico_fecha <- mun_data_generico %>%
      filter(Periodo == fecha)
 
    map_municipios_generico_fecha <- map_municipios %>%
      left_join(mun_data_generico_fecha, by = c("name" = "Municipios"))
    
    map_municipios_generico_fecha <- map_municipios_generico_fecha %>%
      group_by(ine.prov.name) %>%
      mutate(Total = mean(Total, na.rm = TRUE)) %>%
      group_by(ine.prov.name, Total) %>%
      summarise(geometry = st_union(geometry), .groups = "drop")    

    map <- ggplot(data = map_municipios_generico_fecha) +
      geom_sf(aes(fill = Total), color = "white") +
      scale_fill_viridis_c(option = "plasma", na.value = "lightgray") +
      theme_minimal() +
      labs(title = paste(indicador),
           subtitle = paste("Año", fecha),
           fill = "Total")
    print(map)
    
    ggsave(filename = paste0(output_dir, "/", indicador, "_", fecha, ".png"),
           plot = map,
           width = 8, height = 6)
  }
}



```

```{r}
for(fecha in fechas_bucle){
  print(as.Date(fecha))
}
```

